<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Permit Statistics Table</title>
  <style>
    :root {
      --bg: #0f172a;          /* page background: dark slate */
      --card-bg: #0b1120;     /* card background: deep navy */
      --accent: #38bdf8;      /* cyan accent */
      --accent-soft: rgba(56, 189, 248, 0.12);
      --accent-strong: #0ea5e9;
      --text-main: #e5e7eb;   /* light gray text */
      --text-muted: #9ca3af;  /* muted gray text */
      --border-subtle: rgba(148, 163, 184, 0.35);
      --danger: #f97373;
      --radius-lg: 16px;
      --shadow-soft: 0 18px 45px rgba(15, 23, 42, 0.7);
    }
    
    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }
    
    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1e293b 0, #020617 55%);
      color: var(--text-main);
      display: flex;
      justify-content: center;
      padding: 32px 16px;
    }
    
    /* Overall layout container */
    .main-wrapper {
        margin-left: auto;
        margin-right: auto;
        max-width: 900px;
    }
    
    /* Header */
    h1 {
      margin: 0 0 4px 0;
      font-size: 1.9rem;
      text-align: center;
      letter-spacing: 0.03em;
    }
    
    .subtitle {
      margin: 0 0 24px 0;
      font-size: 0.95rem;
      color: var(--text-muted);
      text-align: center;
    }
    
    /* Cards */
    .card {
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.09), transparent 50%),
                  var(--card-bg);
      border-radius: var(--radius-lg);
      padding: 20px 20px 18px 20px;
      box-shadow: var(--shadow-soft);
      border: 1px solid rgba(15, 23, 42, 0.9);
      margin-bottom: 20px;
    }
    
    /* Form layout */
    #stats-form {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .choice-title {
      margin-top: 10px;
      font-size: 0.9rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: var(--accent);
    }
    
    .choice-row {
      display: grid;
      grid-template-columns: 1.3fr 1.3fr 0.8fr;
      gap: 10px;
      margin-top: 4px;
    }
    
    label {
      display: block;
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--text-muted);
    }
    
    /* Inputs & selects */
    input[type="date"],
    input[type="number"],
    select {
      width: 100%;
      margin-top: 4px;
      padding: 8px 10px;
      border-radius: 9px;
      border: 1px solid var(--border-subtle);
      background-color: rgba(15, 23, 42, 0.9);
      color: var(--text-main);
      font-size: 0.9rem;
      outline: none;
      transition: border-color 0.15s ease, box-shadow 0.15s ease, background-color 0.15s ease;
    }
    
    input[type="date"]::placeholder,
    input[type="number"]::placeholder {
      color: var(--text-muted);
    }
    
    input[type="date"]:focus,
    input[type="number"]:focus,
    select:focus {
      border-color: var(--accent-strong);
      box-shadow: 0 0 0 1px var(--accent), 0 0 0 6px rgba(56, 189, 248, 0.12);
      background-color: #020617;
    }
    
    /* Button */
    button[type="submit"] {
      align-self: flex-start;
      margin-top: 14px;
      padding: 10px 20px;
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: linear-gradient(135deg, var(--accent), var(--accent-strong));
      color: #0b1120;
      box-shadow: 0 14px 30px rgba(56, 189, 248, 0.35);
      transition: transform 0.12s ease, box-shadow 0.12s ease, filter 0.12s ease;
    }
    
    button[type="submit"]:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 20px 40px rgba(56, 189, 248, 0.45);
      filter: brightness(1.05);
    }
    
    button[type="submit"]:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: 0 10px 20px rgba(56, 189, 248, 0.25);
    }
    
    button[type="submit"]:disabled {
      opacity: 0.7;
      cursor: not-allowed;
    }
    
    /* Error text */
    #error {
      color: var(--danger);
      margin-top: 8px;
      font-size: 0.8rem;
    }
    
    /* Results card */
    .card h2 {
      margin: 0 0 8px 0;
      font-size: 1.1rem;
    }
    
    #table-container {
      margin-top: 6px;
      overflow-x: auto;
      overflow-y: visible; /* prevent tooltip clipping */
    }
    
    /* Table styling */
    table {
      width: 100%;
      border-collapse: collapse;
      background: rgba(15, 23, 42, 0.9);
      border-radius: 12px;
      overflow: visible; /* allow tooltips to escape the table box */
      border: 1px solid var(--border-subtle);
    }
    
    th,
    td {
      padding: 8px 10px;
      font-size: 0.86rem;
      text-align: center;
      border-bottom: 1px solid rgba(51, 65, 85, 0.9);
    }
    
    th:first-child,
    td:first-child {
      text-align: left;
    }
    
    th {
      background: linear-gradient(to bottom, rgba(15, 23, 42, 0.9), rgba(15, 23, 42, 1));
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }

    th.pred-header {
      text-transform: none;
      letter-spacing: 0.03em; /* optional: softer than 0.08em */
    }
    
    tbody tr:nth-child(odd):not(.totals-row) {
      background-color: rgba(15, 23, 42, 0.7);
    }
    
    tbody tr:nth-child(even):not(.totals-row) {
      background-color: rgba(15, 23, 42, 0.95);
    }
    
    tbody tr:hover:not(.totals-row) {
      background-color: rgba(30, 64, 175, 0.35);
    }
    
    /* Totals row styling */
    .totals-row {
      background: var(--accent-soft);
    }
    
    .totals-row td {
      font-weight: 600;
    }
    
    .totals-row td:first-child {
      color: var(--accent-strong);
    }

    /* Predicted column styling */
    th.pred-col,
    td.pred-col {
      background: rgba(56, 189, 248, 0.06);
    }

    /* Prediction header tooltip (hover/focus) */
    .pred-header .th-label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    
    .info-tip {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      font-size: 12px;
      line-height: 1;
      cursor: help;
      user-select: none;
    
      border: 1px solid var(--border-subtle);
      background: rgba(148, 163, 184, 0.12);
      color: var(--text-main);
    }
    
    .info-tip:focus {
      outline: 2px solid rgba(56, 189, 248, 0.55);
      outline-offset: 2px;
    }
    
    .tooltip {
      /* Do NOT inherit TH uppercase styling */
      text-transform: none;
      letter-spacing: normal;
    
      position: absolute;
      top: calc(100% + 10px);
      right: 0;
      z-index: 50;
    
      width: min(360px, 70vw);
      padding: 12px 12px;
      border-radius: 12px;
    
      background: rgba(2, 6, 23, 0.98);
      border: 1px solid var(--border-subtle);
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.45);
    
      color: var(--text-main);
      font-size: 12.5px;
      line-height: 1.35;
    
      opacity: 0;
      transform: translateY(-4px);
      pointer-events: none;
      transition: opacity 120ms ease, transform 120ms ease;
    }
    
    /* Show on hover OR keyboard focus */
    .info-tip:hover .tooltip,
    .info-tip:focus .tooltip,
    .info-tip:focus-within .tooltip {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }
    
    /* Optional arrow */
    .tooltip::before {
      content: "";
      position: absolute;
      top: -6px;
      right: 10px;
      width: 10px;
      height: 10px;
      transform: rotate(45deg);
      background: rgba(2, 6, 23, 0.98);
      border-left: 1px solid var(--border-subtle);
      border-top: 1px solid var(--border-subtle);
    }

    /* “Comparable date” line in each cell is already a smaller span inline */
    
    /* “No data” cell */
    .no-data {
      color: var(--text-muted);
      font-style: italic;
    }
    
    /* Responsive tweaks */
    @media (max-width: 720px) {
      body {
        padding: 20px 12px;
      }
    
      .card {
        padding: 16px 14px;
      }
    
      .choice-row {
        grid-template-columns: 1fr;
      }
    
      h1 {
        font-size: 1.5rem;
      }

      .card.results-card {
        text-align: center;
      }
      
      .card.results-card table {
        margin-left: auto;
        margin-right: auto;
      }
    }
  </style>
</head>
<body>
  <div class="main-wrapper">
    <div class="card">
      <h1>Enchantments Lottery Statistics</h1>
      <p class="subtitle">
        Enter up to <strong>three</strong> choices. Each choice has its own zone, date, and group size.
        The table will show estimated odds for each choice across the years <strong>2020–2024</strong>,
        along with the comparable date used in each year.
      </p>

      <form id="stats-form">
        <!-- Choice 1 -->
        <div class="choice-title">Choice 1</div>
        <div class="choice-row">
          <div>
            <label>Zone 1:
              <select id="zone1">
                <option value="">-- Select zone --</option>
                <option value="Core">Core</option>
                <option value="Colchuck">Colchuck</option>
                <option value="Snow">Snow</option>
                <option value="Eightmile">Eightmile</option>
                <option value="Stuart">Stuart</option>
              </select>
            </label>
          </div>
          <div>
            <label>Date 1:
              <input type="date" id="date1" min="2026-05-15" max="2026-10-31" />
            </label>
          </div>
          <div>
            <label>Group Size 1:
              <select id="group_size1">
                <option value="">--</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
              </select>
            </label>
          </div>
        </div>

        <!-- Choice 2 -->
        <div class="choice-title">Choice 2</div>
        <div class="choice-row">
          <div>
            <label>Zone 2:
              <select id="zone2">
                <option value="">-- Select zone --</option>
                <option value="Core">Core</option>
                <option value="Colchuck">Colchuck</option>
                <option value="Snow">Snow</option>
                <option value="Eightmile">Eightmile</option>
                <option value="Stuart">Stuart</option>
              </select>
            </label>
          </div>
          <div>
            <label>Date 2:
              <input type="date" id="date2" min="2026-05-15" max="2026-10-31" />
            </label>
          </div>
          <div>
            <label>Group Size 2:
              <select id="group_size2">
                <option value="">--</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
              </select>
            </label>
          </div>
        </div>

        <!-- Choice 3 -->
        <div class="choice-title">Choice 3</div>
        <div class="choice-row">
          <div>
            <label>Zone 3:
              <select id="zone3">
                <option value="">-- Select zone --</option>
                <option value="Core">Core</option>
                <option value="Colchuck">Colchuck</option>
                <option value="Snow">Snow</option>
                <option value="Eightmile">Eightmile</option>
                <option value="Stuart">Stuart</option>
              </select>
            </label>
          </div>
          <div>
            <label>Date 3:
              <input type="date" id="date3" min="2026-05-15" max="2026-10-31" />
            </label>
          </div>
          <div>
            <label>Group Size 3:
              <select id="group_size3">
                <option value="">--</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
              </select>
            </label>
          </div>
        </div>

        <button type="submit" id="submit-button">Fetch Results</button>
        <div id="error"></div>
      </form>

      <h2 style="margin-top: 22px;">Results</h2>
      <div id="table-container">
        <!-- Table will be inserted here -->
      </div>
    </div> <!-- end .card -->
  </div> <!-- end .main-wrapper -->

  <script>
    const API_BASE_URL = '';

        // -------------------------
    // Prediction helpers (2026)
    // -------------------------

    const PREDICT_YEAR = 2026;
    const PREDICT_LABEL = `${PREDICT_YEAR} prediction`;

    function clamp(x, lo, hi) {
      return Math.max(lo, Math.min(hi, x));
    }

    function logit(p) {
      p = clamp(p, 1e-6, 1 - 1e-6);
      return Math.log(p / (1 - p));
    }

    function invLogit(x) {
      const ex = Math.exp(x);
      return ex / (1 + ex);
    }

    // Simple OLS fit for y = a + b*t
    function fitLine(points) {
      const n = points.length;
      const meanT = points.reduce((s, p) => s + p.t, 0) / n;
      const meanY = points.reduce((s, p) => s + p.y, 0) / n;

      let num = 0;
      let den = 0;
      for (const p of points) {
        num += (p.t - meanT) * (p.y - meanY);
        den += (p.t - meanT) * (p.t - meanT);
      }
      const b = den === 0 ? 0 : num / den;
      const a = meanY - b * meanT;
      return { a, b };
    }

    /**
     * Forecast a bounded probability for targetYear using logit-linear trend.
     * Uses the most recent `window` points.
     * Falls back to last-observation-carried-forward if fewer than 2 points.
     */
    function forecastProbLogit(series, targetYear, window = 3) {
      const clean = (series || [])
        .filter(d => Number.isFinite(d.year) && Number.isFinite(d.p))
        .sort((a, b) => a.year - b.year);

      if (clean.length === 0) return null;

      const recent = clean.slice(Math.max(0, clean.length - window));
      if (recent.length === 1) return clamp(recent[0].p, 0, 1);

      const pts = recent.map(d => ({ t: d.year, y: logit(d.p) }));
      const { a, b } = fitLine(pts);

      const yHat = a + b * targetYear;
      return clamp(invLogit(yHat), 0.0005, 0.9995);
    }

    /**
     * Build 2026 predictions for a set of ranked choices using priority-consistent conditioning.
     * Expects resultChoices to be aligned with filledChoices order (Choice 1/2/3).
     *
     * Returns:
     * {
     *   P1, P2, P3, total,
     *   byChoice: [P1, P2, P3] aligned to filledChoices indices
     * }
     *
     * If fewer than 2 filled choices, it still works (predicts what's available).
     */
    function predict2026ForChoiceSet(years, resultChoices, filledChoices) {
      // We only use historical years (exclude any pre-existing pred column)
      const histYears = (years || []).filter(y => Number.isFinite(y));

      // Extract series for P1, and conditional q2/q3
      const P1Series = [];
      const q2Series = [];
      const q3Series = [];

      function getP(choiceIdx, year) {
        const bc = resultChoices[choiceIdx];
        if (!bc) return null;
        const oddsByYear = bc.odds_by_year || {};
        const v = oddsByYear[year];
        return (v === null || v === undefined) ? null : v; // v is already 0..1
      }

      // Build per-year data where available for the ranked set (up to 3)
      for (const y of histYears.slice().sort((a, b) => a - b)) {
        const P1 = filledChoices[0] ? getP(0, y) : null;
        const P2 = filledChoices[1] ? getP(1, y) : null;
        const P3 = filledChoices[2] ? getP(2, y) : null;

        if (Number.isFinite(P1)) {
          P1Series.push({ year: y, p: clamp(P1, 0, 1) });
        }

        // Conditional for choice 2 (if choice 2 exists)
        if (filledChoices[1] && Number.isFinite(P1) && Number.isFinite(P2)) {
          const denom2 = 1 - P1;
          if (denom2 > 1e-9) {
            q2Series.push({ year: y, p: clamp(P2 / denom2, 0, 1) });
          }
        }

        // Conditional for choice 3 (if choice 3 exists)
        if (filledChoices[2] && Number.isFinite(P1) && Number.isFinite(P2) && Number.isFinite(P3)) {
          const denom3 = 1 - P1 - P2;
          if (denom3 > 1e-9) {
            q3Series.push({ year: y, p: clamp(P3 / denom3, 0, 1) });
          }
        }
      }

      // Forecast
      const P1Hat = filledChoices[0] ? forecastProbLogit(P1Series, PREDICT_YEAR, 3) : null;

      // If only Choice 1 provided, total = P1
      if (filledChoices.length === 1) {
        if (P1Hat == null) return null;
        return { P1: P1Hat, P2: null, P3: null, total: P1Hat, byChoice: [P1Hat] };
      }

      const q2Hat = filledChoices[1] ? forecastProbLogit(q2Series, PREDICT_YEAR, 3) : null;
      if (P1Hat == null || q2Hat == null) return null;

      const P2Hat = clamp((1 - P1Hat) * q2Hat, 0, 1);

      // If only Choices 1 & 2
      if (filledChoices.length === 2) {
        const total = clamp(P1Hat + P2Hat, 0, 1);
        return { P1: P1Hat, P2: P2Hat, P3: null, total, byChoice: [P1Hat, P2Hat] };
      }

      const q3Hat = filledChoices[2] ? forecastProbLogit(q3Series, PREDICT_YEAR, 3) : null;
      if (q3Hat == null) return null;

      const remAfter2 = clamp(1 - P1Hat - P2Hat, 0, 1);
      const P3Hat = clamp(remAfter2 * q3Hat, 0, 1);
      const total = clamp(P1Hat + P2Hat + P3Hat, 0, 1);

      return { P1: P1Hat, P2: P2Hat, P3: P3Hat, total, byChoice: [P1Hat, P2Hat, P3Hat] };
    }
  
    // --- Helpers for session & device metadata ---
  
    function getSessionId() {
      let id = localStorage.getItem('sessionId');
      if (!id) {
        if (window.crypto && window.crypto.randomUUID) {
          id = crypto.randomUUID();
        } else {
          id = 'sess-' + String(Math.random()).slice(2);
        }
        localStorage.setItem('sessionId', id);
      }
      return id;
    }
  
    function getNextQueryIndex() {
      const current = Number(localStorage.getItem('queryIndex') || '0');
      const next = current + 1;
      localStorage.setItem('queryIndex', String(next));
      return next;
    }
  
    function getDeviceType() {
      const ua = navigator.userAgent || '';
      if (/Mobi|Android/i.test(ua)) return 'mobile';
      if (/Tablet|iPad/i.test(ua)) return 'tablet';
      return 'desktop';
    }
  
    function getOsName() {
      const ua = navigator.userAgent || '';
      if (ua.includes('Windows')) return 'Windows';
      if (ua.includes('Mac OS') || ua.includes('Macintosh')) return 'macOS';
      if (ua.includes('Linux')) return 'Linux';
      if (ua.includes('Android')) return 'Android';
      if (/iPhone|iPad|iPod/.test(ua)) return 'iOS';
      return 'Unknown';
    }
  
    // Convert "YYYY-MM-DD" (from the form) to "Mmm dd"
    function formatIsoDateToMmmDd(isoDate) {
      if (!isoDate) return '';
      const [yearStr, monthStr, dayStr] = isoDate.split('-');
      const month = parseInt(monthStr, 10);
      const day = parseInt(dayStr, 10);
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      return months[month - 1] + ' ' + day.toString();
    }
  
    // Convert "MM-DD-YYYY" (from backend comparable date) to "Mmm dd"
    function formatMmDdYyyyToMmmDd(mdY) {
      if (!mdY) return '';
      const [monthStr, dayStr, yearStr] = mdY.split('-');
      const month = parseInt(monthStr, 10);
      const day = parseInt(dayStr, 10);
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      return months[month - 1] + ' ' + day.toString();
    }
  
    const form = document.getElementById('stats-form');
    const errorDiv = document.getElementById('error');
    const tableContainer = document.getElementById('table-container');
    const submitButton = document.getElementById('submit-button');
  
    form.addEventListener('submit', async (event) => {
      event.preventDefault();
  
      errorDiv.textContent = '';
      tableContainer.innerHTML = 'Building table...';
  
      // Collect all choices from the form
      const choices = [
        {
          label: 'Choice 1',
          zone: document.getElementById('zone1').value.trim(),
          date: document.getElementById('date1').value,
          groupSizeValue: document.getElementById('group_size1').value
        },
        {
          label: 'Choice 2',
          zone: document.getElementById('zone2').value.trim(),
          date: document.getElementById('date2').value,
          groupSizeValue: document.getElementById('group_size2').value
        },
        {
          label: 'Choice 3',
          zone: document.getElementById('zone3').value.trim(),
          date: document.getElementById('date3').value,
          groupSizeValue: document.getElementById('group_size3').value
        }
      ];
  
      // Keep only rows where zone AND date are filled
      const filledChoices = choices.filter(
        (c) => c.zone !== '' && c.date !== ''
      );
  
      if (filledChoices.length === 0) {
        errorDiv.textContent = 'Please fill in at least one zone/date choice with a group size.';
        tableContainer.innerHTML = '';
        return;
      }

      // Validation: no duplicate zone+date across choices
      const seen = new Map(); // key -> label (e.g., "Core|2026-07-15" -> "Choice 1")
      
      for (const c of filledChoices) {
        // Normalize zone and date just in case
        const zone = (c.zone || '').trim();
        const date = (c.date || '').trim();
      
        const key = zone.toLowerCase() + '|' + date; // case-insensitive zone compare
      
        if (seen.has(key)) {
          const first = seen.get(key);
          errorDiv.textContent =
            `Invalid choices: ${first} and ${c.label} have the same zone and date (${zone}, ${formatIsoDateToMmmDd(date)}). ` +
            `The lottery does not allow duplicate zone/date selections.`;
          tableContainer.innerHTML = '';
          return;
        }
      
        seen.set(key, c.label);
      }
  
      // Extra safety: ensure dates are within the allowed lottery window
      const minDate = new Date('2026-05-15');
      const maxDate = new Date('2026-10-31');
      
      for (const c of filledChoices) {
        const d = new Date(c.date);
        if (isNaN(d.getTime()) || d < minDate || d > maxDate) {
          errorDiv.textContent = 'Dates must be between May 15 and Oct 31, 2026.';
          tableContainer.innerHTML = '';
          return;
        }
      }
  
      // Validate group size for each filled choice
      for (const c of filledChoices) {
        const size = parseInt(c.groupSizeValue, 10);
        if (!c.groupSizeValue || isNaN(size) || size < 1) {
          errorDiv.textContent = `Please enter a valid group size (at least 1) for ${c.label}.`;
          tableContainer.innerHTML = '';
          return;
        }
        c.groupSize = size;
      }
  
      // Use the year from the first filled choice's date as the permit year
      const [permitYearStr] = filledChoices[0].date.split('-');
      const permitYear = parseInt(permitYearStr, 10);
  
      // Historical years used by your databases
      const dataYears = [2020, 2021, 2022, 2023, 2024];
  
      // Prepare payload choices (only filled ones)
      const apiChoices = filledChoices.map((c) => {
        const [yearStr, monthStr, dayStr] = c.date.split('-');
        return {
          zone: c.zone,
          month: parseInt(monthStr, 10),
          day: parseInt(dayStr, 10),
          group_size: c.groupSize
        };
      });
  
      // --- collect session & device metadata for analytics ---
      const sessionId = getSessionId();
      const queryIndex = getNextQueryIndex();
      const deviceType = getDeviceType();
      const browserUa = navigator.userAgent || '';
      const osName = getOsName();
  
      const payload = {
        permit_year: permitYear,
        data_years: dataYears,
        choices: apiChoices,
  
        // These fields line up with OddsRequest in main.py
        session_id: sessionId,
        query_index: queryIndex,
        device_type: deviceType,
        browser: browserUa,
        os_name: osName
        // latency_ms: can be added later if we want
      };
  
      console.log('Payload to /estimate_odds:', payload);
  
      submitButton.disabled = true;
      submitButton.textContent = 'Loading...';
  
      try {
        const response = await fetch(API_BASE_URL + '/estimate_odds', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(payload)
        });
  
        if (!response.ok) {
          errorDiv.textContent = 'Error from server: ' + response.status + ' ' + response.statusText;
          tableContainer.innerHTML = '';
          return;
        }
  
        const data = await response.json();
  
        const years = data.years || [];
        const resultChoices = data.choices || [];

        // Append a prediction column (2026) to the rendered table.
        // Keep a separate copy of historical years for modeling.
        const historicalYears = years.slice(); // expected: [2020..2024]
        const yearsWithPred = years.slice();
        yearsWithPred.push(PREDICT_LABEL);
  
        // Build table
        const table = document.createElement('table');
  
        // Header row
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        const firstHeader = document.createElement('th');
        firstHeader.textContent = 'Zone / Date / Group Size';
        headerRow.appendChild(firstHeader);
  
        yearsWithPred.forEach((year) => {
          const th = document.createElement('th');
        
          // Prediction column header: add tooltip + styling
          if (year === PREDICT_LABEL) {
            th.classList.add('pred-col', 'pred-header');
        
            // Build label + info icon + tooltip
            th.innerHTML = `
              <span class="th-label">
                ${year.toString()}
                <span class="info-tip" tabindex="0" aria-label="Prediction explanation">
                  ⓘ
                  <span class="tooltip" role="tooltip">
                    2026 odds are estimated from recent trends 
                    and adjusted to reflect how the lottery 
                    processes first, second, and third choices.
                  </span>
                </span>
              </span>
            `;
          } else {
            // Normal historical year headers
            th.textContent = year.toString();
          }
        
          headerRow.appendChild(th);
      });
  
        thead.appendChild(headerRow);
        table.appendChild(thead);
  
        const tbody = document.createElement('tbody');

        // Compute 2026 predictions for the whole ranked set (uses priority conditioning)
        const pred = predict2026ForChoiceSet(historicalYears, resultChoices, filledChoices);
  
        // For each filled choice, add a row
        filledChoices.forEach((c, index) => {
          const backendChoice = resultChoices[index];
  
          const row = document.createElement('tr');
  
          const labelCell = document.createElement('td');
          const prettyPermitDate = formatIsoDateToMmmDd(c.date);
          labelCell.textContent =
            `${c.label}: ${c.zone} (${prettyPermitDate}), ${c.groupSize} people`;
          row.appendChild(labelCell);
  
          yearsWithPred.forEach((year) => {
            const cell = document.createElement('td');

            // Prediction column
            if (year === PREDICT_LABEL) {
              cell.classList.add('pred-col');
            
              if (!pred || !pred.byChoice || pred.byChoice[index] == null) {
                cell.textContent = '';
                cell.classList.add('no-data');
              } else {
                cell.textContent = (pred.byChoice[index] * 100).toFixed(1) + '%';
              }
            
              row.appendChild(cell);
              return;
            }

            // Historical columns
            if (!backendChoice) {
              cell.textContent = 'N/A';
              cell.className = 'no-data';
              row.appendChild(cell);
              return;
            }

            const oddsByYear = backendChoice.odds_by_year || {};
            const compDatesByYear = backendChoice.comp_dates_by_year || {};

            const value = oddsByYear[year];
            const compDate = compDatesByYear[year];

            if (value === null || value === undefined) {
              cell.textContent = '';
            } else {
              const prettyCompDate = compDate ? formatMmDdYyyyToMmmDd(compDate) : '';

              if (prettyCompDate) {
                cell.innerHTML =
                  (value * 100).toFixed(1) + '%' +
                  '<br><span style="font-size: 0.85em; color: var(--text-muted);">' +
                  prettyCompDate +
                  '</span>';
              } else {
                cell.textContent = (value * 100).toFixed(1) + '%';
              }
            }

            row.appendChild(cell);
          });
  
          tbody.appendChild(row);
        });
  
        // Add a totals row: sum of odds across all choices for each year
        const totalsRow = document.createElement('tr');
        totalsRow.classList.add('totals-row');
  
        // Label cell
        const totalsLabelCell = document.createElement('td');
        totalsLabelCell.textContent = 'Total odds of winning any choice';
        totalsLabelCell.style.fontWeight = 'bold';
        totalsRow.appendChild(totalsLabelCell);
  
        // One cell per year with the summed odds
        yearsWithPred.forEach((year) => {
          const cell = document.createElement('td');
          cell.style.fontWeight = 'bold';

          if (year === PREDICT_LABEL) {
            cell.classList.add('pred-col');
          
            if (!pred || pred.total == null) {
              cell.textContent = '';
              cell.classList.add('no-data');
            } else {
              cell.textContent = (pred.total * 100).toFixed(1) + '%';
            }
          
            totalsRow.appendChild(cell);
            return;
          }

          // Historical totals
          let total = 0;

          filledChoices.forEach((c, index) => {
            const backendChoice = resultChoices[index];
            if (!backendChoice) return;

            const oddsByYear = backendChoice.odds_by_year || {};
            const value = oddsByYear[year];

            if (value !== null && value !== undefined) {
              total += value;
            }
          });

          cell.textContent = (total * 100).toFixed(1) + '%';
          totalsRow.appendChild(cell);
        });
  
        tbody.appendChild(totalsRow);
  
        table.appendChild(tbody);
        tableContainer.innerHTML = '';
        tableContainer.appendChild(table);
  
      } catch (err) {
        console.error(err);
        errorDiv.textContent = 'Something went wrong while contacting the server.';
        tableContainer.innerHTML = '';
      } finally {
        submitButton.disabled = false;
        submitButton.textContent = 'Fetch Results';
      }
    });
  </script>
</body>
</html>



